---
title: The Quest For Perfect Plaintext Input
publishedAt: 2025-05-30
subtitle: "Will this new value makes us drop textarea?"
isDraft: false
tags:
  - web
---

March 2025 has brought us a new update to the web platform: the induction of `plaintext-only` value for
`contenteditable` attribute to [Widely Available Baseline](https://web.dev/blog/contenteditable-plaintext-only-baseline),
which is a prevalent attribute commonly used in WYSIWYG editors.

As the name suggest, using this value will narrow down the value that may be received by the `contenteditable` element to only plaintext values.

However we already have the good old `<textarea>` to handle freeform plaintext inputs, so what is WHATWG thinking when creating
this new value?

## When Textarea Isn't Enough

Since its introduction of HTML2 in [November 1995](https://www.w3.org/MarkUp/html-spec/), multi-line plaintext inputs has always
been traditionally defined with the `<textarea>` element instead of `<input>`.

<figure class="my-4 w-full max-w-4/5 mx-auto">
  <textarea class="border border-separator p-2 font-mono w-full bg-background transition-colors">Hello, I'm textarea ðŸ‘‹</textarea>
  <figcaption class="text-xs italic text-center">An example of textarea with minimal setup</figcaption>
</figure>

The main difference between `<textarea>` and `<input>` element beside the wrapping behavior is the additional handle on the bottom right
of the element for resizing and the addition of `rows` and `cols` attribute that controls the initial size of the element.

As you started adopting `<textarea>`, you will begin to realize that your styling options to the contents inside the `<textarea>`
is only limited to inherited attributes that you can define in `<textarea>`.

Contents inside `<textarea>` are treated the same way as [replaced elements](https://html.spec.whatwg.org/multipage/rendering.html#replaced-elements),
they have their own intrinsic dimensions and it's up to the user agent to control how the contents are rendered.

Just like `<input>`, the user agent internally uses [Shadow DOM](https://developer.mozilla.org/en-US/docs/Web/API/Web_components/Using_shadow_DOM)
to isolate the contents of `<textarea>` into its own DOM tree.

![User agent Shadow DOM that encapsulate the contents of textarea (need to explicitly enable in DevTools)](https://res.cloudinary.com/namchee/image/upload/v1748674003/posts/the-quest-for-perfect-plaintext-input/textarea-shadow-dom)

Since the contents largely exist outside the developer-controlled [CSS rendering model](https://www.w3.org/TR/WD-CSS2/visuren.html),
`<textarea>` lacked the native capability to automatically resize itself which is a common usecase for modern UI interfaces.

To address this issue, developers usually handles it with JavaScript in similar fashion as the following:

```js title=textarea.js
const textarea = document.querySelector('.textarea__autosize');

function resizeTextarea(el) {
  // Reset textarea height to auto to correctly calculate the new height
  el.style.height = 'auto';
  const newHeight = el.scrollHeight;

  el.style.height = `${newHeight}px`;
  el.style.overflowY = 'hidden';

  /**
   * If you want autosize to a certain max number of rows:
   *
   * const MAX_ROWS = 8;
   *
   * // Calculate maximum height from maxRows
   * const lineHeight =
   *   parseInt(window.getComputedStyle(el).lineHeight, 10) || 0;
   *
   * const maxHeight = lineHeight * maxRows;
   *
   * if (newHeight > maxHeight) {
   *   el.style.height = `${maxHeight}px`;
   *   el.style.overflowY = 'scroll';
   * }
   */
}

textarea.addEventListener('input', () => resizeTextarea(el));
```

While the autosizing implementation above works, it introduces 2 new problems:

- Reliance to JavaScript, even though `<textarea>` works fine without it
- Developers need to wire the autosizing logic manually to other events such as `paste` and direct value modification
through element reference with `.innerHTML`, depending on the requirements. Failing to handle events might cause the `<textarea>`
to not autosize itself and hurting UX in the process.

As for the list of other CSS features that don't work at all without wizardy in `<textarea>` due to Shadow DOM encapsulation:

- `::before` and `::after` pseudo element
- Scrollbar-related styling prefixed with `-webkit-scrollbar`
- [CSS Highlight API](https://developer.mozilla.org/en-US/docs/Web/API/CSS_Custom_Highlight_API)

To address the issues with `<textarea>`, developers tend to replace their multi-line plaintext inputs with
`<div>` with additional `contenteditable` attribute. But does `<div contenteditable>` truly solve our problems?

## When Contenteditable Is Too Much

In July 2000, Microsoft introduced `designMode` and `contenteditable` attributes through Internet Explorer
([RIP](https://techcommunity.microsoft.com/blog/windows-itpro-blog/internet-explorer-11-desktop-app-retirement-faq/2366549)) 5.5.

The details were pretty lacking, but Ian Hickson wrote a [WHATWG blogpost](https://lists.whatwg.org/pipermail/whatwg-whatwg.org/2004-November/002313.html)
outlining the main purpose of these new attributes: extending the capability of `<textarea>` for
rich-text formatting in general like WYSIWYG editors.

While `designMode` makes the *entire document* editable, `contenteditable` isolate the editability to a certain element, which in context of multi-line plaintext input, a `<div>`.

<figure class="my-4 w-full max-w-4/5 mx-auto">
  <div contenteditable class="border border-separator p-2 font-mono w-full bg-background transition-colors min-h-16">Hello, I'm a contenteditable div ðŸ‘‹</div>
  <figcaption class="text-xs italic text-center mt-2">An example of contenteditable div with minimal setup</figcaption>
</figure>

When you play around with the example above, you might realize that the container automatically resize itself
when you fired input events while you focus on them.

Unlike `<textarea>`, contents inside a `contenteditable` element are enclosed inside the CSS rendering model.

## Plaintext-only: The Middleground

## Will It Kill Textarea?
