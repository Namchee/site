---
title: The Quest For Perfect Plaintext Input
publishedAt: 2025-05-30
subtitle: "Will this new value makes us drop textarea?"
isDraft: false
tags:
  - web
  - CSS
---

March 2025 has brought us a new update to the web platform: the induction of `plaintext-only` value for
`contenteditable` attribute to [Widely Available Baseline](https://web.dev/blog/contenteditable-plaintext-only-baseline),
which is a prevalent attribute commonly used in WYSIWYG editors.

As the name suggest, using this value will narrow down the value that may be received by the `contenteditable` element to only plaintext values.

However we already have the good old `<textarea>` to handle freeform plaintext inputs, so what is WHATWG thinking when creating
this new value?

## When Textarea Isn't Enough

Since its introduction of HTML2 in [November 1995](https://www.w3.org/MarkUp/html-spec/), multi-line plaintext inputs has always
been traditionally defined with the `<textarea>` element instead of `<input>`.

<figure class="my-4 w-full max-w-4/5 mx-auto">
  <textarea class="border border-separator p-2 font-mono w-full bg-background transition-colors" placeholder="Hello, I'm textarea ðŸ‘‹"></textarea>
  <figcaption class="text-xs italic text-center">An example of textarea with minimal setup</figcaption>
</figure>

The main difference between `<textarea>` and `<input>` element beside the wrapping behavior is the additional handle on the bottom right
of the element for resizing and the addition of `rows` and `cols` attribute that controls the initial size of the element.

As you started adopting `<textarea>`, you will begin to realize that your styling options to the contents inside the `<textarea>`
is only limited to inherited attributes that you can define in `<textarea>`.

Contents inside `<textarea>` are treated the same way as [replaced elements](https://html.spec.whatwg.org/multipage/rendering.html#replaced-elements),
they have their own intrinsic dimensions and it's up to the user agent to control how the contents are rendered.

Just like `<input>`, the user agent internally uses [Shadow DOM](https://developer.mozilla.org/en-US/docs/Web/API/Web_components/Using_shadow_DOM)
to isolate the contents of `<textarea>` into its own DOM tree.

![User agent Shadow DOM that encapsulate the contents of textarea (need to explicitly enable in DevTools)](https://res.cloudinary.com/namchee/image/upload/v1748674003/posts/the-quest-for-perfect-plaintext-input/textarea-shadow-dom)

Since the contents largely exist outside the developer-controlled [CSS rendering model](https://www.w3.org/TR/WD-CSS2/visuren.html),
`<textarea>` lacked the native capability to automatically resize itself which is a common usecase for modern UI interfaces.

To address this issue, developers usually handles it with JavaScript in similar fashion as the following:

```js title=textarea.js
const textarea = document.querySelector('.textarea__autosize');

function resizeTextarea(el) {
  // Reset textarea height to auto to correctly calculate the new height
  el.style.height = 'auto';
  const newHeight = el.scrollHeight;

  el.style.height = `${newHeight}px`;
  el.style.overflowY = 'hidden';

  /**
   * If you want autosize to a certain max number of rows:
   *
   * const MAX_ROWS = 8;
   *
   * // Calculate maximum height from maxRows
   * const lineHeight =
   *   parseInt(window.getComputedStyle(el).lineHeight, 10) || 0;
   *
   * const maxHeight = lineHeight * maxRows;
   *
   * if (newHeight > maxHeight) {
   *   el.style.height = `${maxHeight}px`;
   *   el.style.overflowY = 'scroll';
   * }
   */
}

textarea.addEventListener('input', () => resizeTextarea(el));
```

While the autosizing implementation above works, it introduces 2 new problems:

- Reliance to JavaScript, even though `<textarea>` works fine without it
- Developers need to wire the autosizing logic manually to other events such as `paste` and direct value modification
through element reference with `.innerHTML`, depending on the requirements. Failing to handle events might cause the `<textarea>`
to not autosize itself and hurting UX in the process.

As for the list of other CSS features that don't work at all without wizardy in `<textarea>` due to Shadow DOM encapsulation:

- `::before` and `::after` pseudo element
- `caret-color`
- Scrollbar-related styling prefixed with `-webkit-scrollbar`
- [CSS Highlight API](https://developer.mozilla.org/en-US/docs/Web/API/CSS_Custom_Highlight_API)

To address the issues with `<textarea>`, developers tend to replace their multi-line plaintext inputs with
`<div>` with additional `contenteditable` attribute. But does `<div contenteditable>` truly solve our problems?

## Contenteditable: New Set of Problems

In July 2000, Microsoft introduced `designMode` and `contenteditable` attributes through Internet Explorer
([RIP](https://techcommunity.microsoft.com/blog/windows-itpro-blog/internet-explorer-11-desktop-app-retirement-faq/2366549)) 5.5.

The details were pretty lacking, but Ian Hickson wrote a [WHATWG blogpost](https://lists.whatwg.org/pipermail/whatwg-whatwg.org/2004-November/002313.html)
outlining the main purpose of these new attributes: extending the capability of `<textarea>` for
rich-text formatting in general like WYSIWYG editors.

While `designMode` makes the *entire document* editable, `contenteditable` isolate the editability to a certain element,
which in context of multi-line plaintext input, a `<div>`.

<figure class="my-4 w-full max-w-4/5 mx-auto">
  <div
    contenteditable
    class="border border-separator p-2 font-mono w-full bg-background transition-colors contenteditable__autoresize"
    role="textbox"
    placeholder="Hello, I'm a contenteditable div ðŸ‘‹"
    aria-placeholder="Hello, I'm a contenteditable div ðŸ‘‹"
  ></div>
  <figcaption class="text-xs italic text-center mt-2">An example of contenteditable div with minimal setup</figcaption>
</figure>

When you play around with the example above, you might realize that the container automatically resize itself
when you fired input events on it. Limiting the number of lines until overflow also can be implemented with only CSS.

```css title=contenteditable.css, copy
:root {
  /* Assume that we want a maximum of 8 lines before resizing */
  --maximum-lines: 8;
}

.contenteditable__autoresize {
  line-height: 1.5;
  min-height: calc(4rem + 16px);
  max-height: calc(var(--maximum-lines) * 1.5rem + 16px);
  overflow: auto;
  /* Ensure no width transition when scrollbar appears */
  scrollbar-gutter: stable;
}

/* Emulate <textarea> placeholder */
.contenteditable__autoresize:empty::before {
  content: attr(placeholder);
  opacity: 0.5;
  pointer-events: none;
}
```

Unlike `<textarea>`, contents inside a `contenteditable` element are enclosed inside the CSS rendering model. Since
the contents are inside the usual DOM tree, it supports everything that `<textarea>` doesn't support.

Perhaps due to wider CSS features it supports, many modern applications has implemented their multiline text inputs with `<div contenteditable>`
instead of `<textarea>` even though they don't deal with WYSIWYG.

![Bluesky uses contenteditable div instead of textarea for their New Post input](https://res.cloudinary.com/namchee/image/upload/v1748700530/posts/the-quest-for-perfect-plaintext-input/bsky)

Going back to the context however, it's quite obvious that `<div contenteditable>` is doing *too much*
with it's rich-text formatting support since we're only dealing with multi-line **plaintext** input.

While normal inputs don't get rich-text formatted by default, we need to drop the rich-text formatting
capability during `paste` event:

```js title=Removing rich-text from paste event, copy
const contenteditable = document.querySelector(
  '.contenteditable__autosize'
);

contenteditable.addEventListener('paste', (e) => {
  e.preventDefault();

  // remove text formatting from clipboard
  const pastedText = (e.clipboardData || window.clipboardData).getData('text/plain');

  // get the current caret position
  const selection = window.getSelection();
  if (!selection.rangeCount) {
    return;
  }

  // remove the selected text first!
  selection.deleteFromDocument();
  selection.getRangeAt(0).insertNode(document.createTextNode(pastedText));

  selection.collapseToEnd();
});
```

We also need to be careful when we're trying to modify the input value directly through reference, as we can't
use `.innerHTML` since the value will be treated as rich-texts without sanitation.

Since we still need to do some legwork in JavaScript, can we do better with `<div contenteditable>` for our plaintext input?
Fortunately, a usecase where rich-text formatting isn't needed is what `plaintext-only` value aims to solve.

Basically, a `contenteditable` with `plaintext-only` strips all rich-text formatting from the clipboard payload
before applying the value to the input which you can try from the following element:

<figure class="my-4 w-full max-w-4/5 mx-auto">
  <div
    contenteditable="plaintext-only"
    class="border border-separator p-2 font-mono w-full bg-background transition-colors contenteditable__autoresize contenteditable__plaintext"
    role="textbox"
    placeholder="Hello, I'm a plaintext-only contenteditable div ðŸ‘‹"
    aria-placeholder="Hello, I'm a plaintext-only contenteditable div ðŸ‘‹"
  ></div>
  <figcaption class="text-xs italic text-center mt-2">An example of contenteditable div, but plaintext</figcaption>
</figure>

At first glance, `<div contenteditable="plaintext-only">` seems to make `<textarea>` obsolete as it successfully
covers plaintext needs while supporting CSS features due to its implementation that exist in normal DOM tree.

However, `<div contenteditable>` in general have their own unique problems compared to `<textarea>`:

## Choosing The Perfect Input Element



## Final Thoughts

