---
title: The Quest For Perfect Freeform Input
publishedAt: 2025-05-30
subtitle: Will the new plaintext-only replace textarea?
isDraft: false
tags:
  - web
  - CSS
---

March 2025 has brought us a new update to the web platform: the induction of `plaintext-only` value for
`contenteditable` attribute to [Widely Available Baseline](https://web.dev/blog/contenteditable-plaintext-only-baseline),
which is a prevalent attribute commonly used in rich-text editors.

From what we can discern from the name alone, `plaintext-only` seems to strip down all rich-text formattings
from values inside `contenteditable` into plaintexts.

However, won't that defeat the purpose of `contenteditable` in the first place? Moreover, we already have good old
`<textarea>` to handle freeform inputs. What is WHATWG trying to solve when introducting this new value?

## When Textarea Isn't Enough

Since its introduction of HTML2 in [November 1995](https://www.w3.org/MarkUp/html-spec/), freeform inputs has always
been traditionally defined with the `<textarea>` element instead of `<input>`.

<figure class="my-4 w-full max-w-4/5 mx-auto">
  <textarea class="border border-separator p-2 font-mono w-full bg-background transition-colors" placeholder="Hello, I'm textarea ðŸ‘‹"></textarea>
  <figcaption class="text-xs italic text-center">An example of textarea with minimal setup</figcaption>
</figure>

The main difference between `<textarea>` and `<input>` element beside the wrapping behavior is the additional handle on the bottom right
of the element for resizing and the addition of `rows` and `cols` attribute that controls the initial size of the element.

As you started adopting `<textarea>`, you will begin to realize that your styling options to the contents inside the `<textarea>`
is only limited to inherited attributes that you can define in `<textarea>`.

Contents inside `<textarea>` are treated the same way as [replaced elements](https://html.spec.whatwg.org/multipage/rendering.html#replaced-elements),
they have their own intrinsic dimensions and it's up to the user agent to control how the contents are rendered.

Just like `<input>`, the user agent internally uses [Shadow DOM](https://developer.mozilla.org/en-US/docs/Web/API/Web_components/Using_shadow_DOM)
to isolate the contents of `<textarea>` into its own DOM tree.

![User agent Shadow DOM that encapsulate the contents of textarea (need to explicitly enable in DevTools)](https://res.cloudinary.com/namchee/image/upload/v1748674003/posts/the-quest-for-perfect-plaintext-input/textarea-shadow-dom)

Since the contents largely exist outside the developer-controlled [CSS rendering model](https://www.w3.org/TR/WD-CSS2/visuren.html),
`<textarea>` lacked the native capability to automatically resize itself which is a common usecase for modern UI interfaces.

To address this issue, developers usually handles it with JavaScript in similar fashion as the following:

```js title=textarea.js
const textarea = document.querySelector('.textarea__autosize');

function resizeTextarea(el) {
  // Reset textarea height to auto to correctly calculate the new height
  el.style.height = 'auto';
  const newHeight = el.scrollHeight;

  el.style.height = `${newHeight}px`;
  el.style.overflowY = 'hidden';

  /**
   * If you want autosize to a certain max number of rows:
   *
   * const MAX_ROWS = 8;
   *
   * // Calculate maximum height from maxRows
   * const lineHeight =
   *   parseInt(window.getComputedStyle(el).lineHeight, 10) || 0;
   *
   * const maxHeight = lineHeight * maxRows;
   *
   * if (newHeight > maxHeight) {
   *   el.style.height = `${maxHeight}px`;
   *   el.style.overflowY = 'scroll';
   * }
   */
}

textarea.addEventListener('input', () => resizeTextarea(el));
```

While the autosizing implementation above works, it introduces 2 new problems:

- Reliance to JavaScript, even though `<textarea>` works fine without it
- Developers must manually wire autosizing logic to various HTML events like `paste` or direct value changes via `.innerHTML`.
Otherwise, the `<textarea>` may not resize correctly, which might hurt the UX.

As for the list of other CSS features that don't work at all in `<textarea>` without some wizardy due to Shadow DOM encapsulation:

- `::before` and `::after` pseudo element
- `caret-color`
- Scrollbar-related styling prefixed with `-webkit-scrollbar`
- [CSS Highlight API](https://developer.mozilla.org/en-US/docs/Web/API/CSS_Custom_Highlight_API)

To address the issues with `<textarea>`, developers tend to replace their freeform inputs with
a `contenteditable` element even when rich-text formatting isn't needed.

However, many people who haven't dealt with `contenteditable` before don't
realize that `contenteditable` comes with its own set of problems compared to `<textarea>` until
they've delved too far with it.

## Contenteditable: New Set of Problems

If you're not living in a cave in the past decade, you might notice that some of the freeform input inside
you favorite apps are capable of rendering wider variety of style and formats unlike what `<textarea>` can provide with plaintext.

Rich-text capabilities like that are commonly provided by `contenteditable`, which can usually be seen in discussion and social media platforms.

![Bluesky post editor using contenteditable provided by ProseMirror](https://res.cloudinary.com/namchee/image/upload/v1748700530/posts/the-quest-for-perfect-plaintext-input/bsky)

The attribute itself is surprisingly old, as it's first introduced in July 2000 by Microsoft alongside `designMode` through Internet Explorer
([RIP](https://techcommunity.microsoft.com/blog/windows-itpro-blog/internet-explorer-11-desktop-app-retirement-faq/2366549)) 5.5.

The details were pretty lacking, but Ian Hickson wrote a [WHATWG blogpost](https://lists.whatwg.org/pipermail/whatwg-whatwg.org/2004-November/002313.html)
outlining the main purpose of these new attributes: extending the capability of `<textarea>` for
rich-text formatting in general like WYSIWYG editors.

While `designMode` makes the *entire document* editable, `contenteditable` isolate the editability to a certain element.
Usually, a `<div>` is used as a container for a freeform input defined with `contenteditable`.

<figure class="my-4 w-full max-w-4/5 mx-auto">
  <div
    contenteditable
    class="border border-separator p-2 font-mono w-full bg-background transition-colors contenteditable__autoresize"
    role="textbox"
    placeholder="Hello, I'm a contenteditable div ðŸ‘‹"
    aria-placeholder="Hello, I'm a contenteditable div ðŸ‘‹"
  />
  <figcaption class="text-xs italic text-center mt-2">An example of contenteditable div with minimal setup</figcaption>
</figure>

Aside from the obvious rich-text formatting capabilities, you might realize that the container automatically resize itself
when you fired input events on it. Limiting the number of lines until overflow also can be implemented with only CSS.

```css title=contenteditable.css, copy
:root {
  /* Assume that we want a maximum of 8 lines before resizing */
  --maximum-lines: 8;
}

.contenteditable__autoresize {
  line-height: 1.5;
  min-height: calc(4rem + 16px);
  max-height: calc(var(--maximum-lines) * 1.5rem + 16px);
  overflow: auto;
  /* Ensure no width transition when scrollbar appears */
  scrollbar-gutter: stable;
}

/* Emulate <textarea> placeholder */
.contenteditable__autoresize:empty::before {
  content: attr(placeholder);
  opacity: 0.5;
  pointer-events: none;
}
```

Unlike `<textarea>`, contents inside `contenteditable` are rendered inside the scope of normal DOM tree.
Since the contents exist inside the CSS rendering model, it supports more CSS features that `<textarea>` doesn't support.

On the surface, `contenteditable` seems like a `<textarea>` with rich-text capabilities and broader CSS feature support.
However, playing around `contenteditable` reveals plethora of problems that `<textarea>` doesn't have:

- Form submissions require JavaScript
- No *native* `<label>` and `placeholder` support
- A block-level `contenteditable` always insert an extra `<br />` after interaction to preserve visibility which
breaks the `:empty` pseudo-class
- Developers need to handle accessibility attributes through ARIA manually, which usually aren't used
[responsibly](https://www.w3.org/WAI/ARIA/apg/practices/read-me-first/) or [used in a wrong way](https://webaim.org/projects/million/)
- ...[and many more](https://ckeditor.com/blog/ContentEditable-The-Good-the-Bad-and-the-Ugly/)

## Plaintext-only Is Misleading

Going back to the context however, it's quite obvious that `<div contenteditable>` is doing *too much*
with it's rich-text formatting support since we're only dealing with multi-line **plaintext** input.

While normal inputs don't get rich-text formatted by default, we need to drop the rich-text formatting
capability during `paste` event:

```js title=Removing rich-text from paste event, copy
const contenteditable = document.querySelector(
  '.contenteditable__autosize'
);

contenteditable.addEventListener('paste', (e) => {
  e.preventDefault();

  // remove text formatting from clipboard
  const pastedText = (e.clipboardData || window.clipboardData).getData('text/plain');

  // get the current caret position
  const selection = window.getSelection();
  if (!selection.rangeCount) {
    return;
  }

  // remove the selected text first!
  selection.deleteFromDocument();
  selection.getRangeAt(0).insertNode(document.createTextNode(pastedText));

  selection.collapseToEnd();
});
```

We also need to be careful when we're trying to modify the input value directly through reference, as we can't
use `.innerHTML` since the value will be treated as rich-texts without sanitation.

Since we still need to do some legwork in JavaScript, can we do better with `contenteditable` for our plaintext input?
Fortunately, the `plaintext-only` value is introduced for use cases where rich-text formatting isn't necessary.

Basically, a `contenteditable` with `plaintext-only` strips all rich-text formatting from the clipboard payload
before applying the value to the input which you can try from the following element:

<figure class="my-4 w-full max-w-4/5 mx-auto">
  <div
    contenteditable="plaintext-only"
    class="border border-separator p-2 font-mono w-full bg-background transition-colors contenteditable__autoresize contenteditable__plaintext min-h-16"
    role="textbox"
    placeholder="Hello, I'm a plaintext-only contenteditable div ðŸ‘‹"
    aria-placeholder="Hello, I'm a plaintext-only contenteditable div ðŸ‘‹"
  />
  <figcaption class="text-xs italic text-center mt-2">An example of contenteditable div, but plaintext</figcaption>
</figure>

Rich-text formatting that are directly applied through `.innerHTML` will still be applied to the element. Simply put, `plaintext-only` is a
normal `contenteditable` with plaintext `paste` event handler implicitly attached to it.

While `contenteditable` have much better support on some CSS features, `contenteditable` have their own unique problems that
`<textarea>` doesn't have as a multi-line plaintext input element:



## Choosing Your Own Poison

We now know that we have both `contenteditable` with `plaintext-only` and `<textarea>` to represent a multi-line plaintext input.

Since both have their own advantages and weaknesses unique to each other, you might be wondering: which one should you choose for your project?



//... flowchart here

## Final Thoughts

