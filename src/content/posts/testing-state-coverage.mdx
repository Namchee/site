---
title: 'Completing Tests with State Coverage'
publishedAt: 2023-12-17
subtitle: 'Using state coverage as an additional measure of test quality'
isDraft: true
tags:
  - engineering
  - testing
---

import Tweet from 'astro-tweet';

import TextLink from './../../components/astro/ui/TextLink.astro';
import Head2 from './../../components/astro/modules/posts/html/Head2.astro';
import Head3 from './../../components/astro/modules/posts/html/Head3.astro';
import Strong from './../../components/astro/modules/posts/html/Strong.astro';
import Quote from './../../components/astro/modules/posts/html/Quote.astro';

import ListTitle from './../../components/astro/modules/posts/html/ListTitle.astro';
import ListItem from './../../components/astro/modules/posts/html/ListItem.astro';

import Image from './../../components/astro/modules/posts/html/Image.astro';

import CodeSnippet from './../../components/astro/modules/posts/html/CodeSnippet.astro';


export const components = {
  a: TextLink,
  h2: Head2,
  h3: Head3,
  strong: Strong,
  img: Image,
  pre: CodeSnippet,
}

Throughout my software engineering journey,testing has been an integral part of the development lifecycle.
While the lack of tests guarantees low-quality code, having tests doesn't guarantee high quality code.

To ensure code quality, we need to ensure that the tests themselves are high quality. A common metric used to measure
test quality is **code coverage**. For many projects, code coverage is used as one of a threshold for an acceptable code.

Sadly, there is still a lot of engineers that fails to understand code coverage as **a** metric for tests and abused it
as the holy grail of metrics. In my observation, code coverage is commonly abused in two ways:

<dl class=":uno: space-y-2">
  <ListTitle>
    Setting code coverage to an exceedingly high threshold
  </ListTitle>
  <ListTitle>
    Using code coverage as the perfect metric of test quality
  </ListTitle>
</dl>

While it's debatable on how much should an effective code coverage be, code coverage shouldn't be **the** metric for
test quality. To understand why code coverage isn't enough, we need to understand how code coverage is calculated.

## Measuring the Coverage

These days, it's rare to find a language ecosystem that doesn't have a test ecosystem. Depending on the maturity of the
ecosystem of the tech stack, we can easily test our code by writing the tests as a code in a testing framework and execute
them with an automated test runner.

Most of the time, modern test ecosystem also includes an additional tool called **coverage reporter** that instruments and
collect metrics of executed lines, branches, statements, blocks, etc of our code. These metrics will then be compared to the
same metrics of the code, resulting in a percentage of coverage.

To illustrate it better, suppose that we have the following code:

```ts title=math.ts
export function add(a: number, b: number): number {
    return a + b;
}

export function subtract(a: number, b: number): number {
    return a - b;
}

export function divide(a: number, b: number): number {
    return a / b;
}

export function modulo(a: number, b: number): number {
    return a % b;
}
```

which is tested by the following test file:

```ts title=math.spec.ts
import { describe, it, expect } from 'vitest';

import { add, subtract, divide } from './math';

describe('Math Operations', () => {
  it('should add two numbers', () => {
    expect(add(1, 2)).toBe(3);
  });

  it('should subtract two numbers', () => {
    expect(subtract(5, 3)).toBe(2);
  });

  it('should divide two numbers', () => {
    expect(divide(10, 2)).toBe(5);
  });
});
```

After execution, our test runner reports the following code coverage:

```bash no-lang
----------|---------|----------|---------|---------|-------------------
File      | % Stmts | % Branch | % Funcs | % Lines | Uncovered Line #s
----------|---------|----------|---------|---------|-------------------
All files |   86.66 |      100 |      75 |   86.66 |
 math.ts  |   86.66 |      100 |      75 |   86.66 | 14-15
----------|---------|----------|---------|---------|-------------------
```

The code coverage report shows that the test covers all possible branches, as the source code doesn't have any alternative
path of execution through a branching statement such as `if` or `switch`.

However, the coverage report also shows that the test haven't fully explored all statements, functions, and lines in our code
as the `modulo` function is not executed in any test scenario.

### What Coverage is Good At

There are 2 advantages

that leads to counter intuitive hacks such as
[assertion-free testing](https://martinfowler.com/bliki/AssertionFreeTesting.html).
