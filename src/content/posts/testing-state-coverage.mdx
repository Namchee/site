---
title: 'Increasing the State Coverage'
publishedAt: 2023-12-17
subtitle: 'Using state coverage as an additional measure of test quality'
isDraft: true
tags:
  - engineering
  - testing
---

import Tweet from 'astro-tweet';

import TextLink from './../../components/astro/ui/TextLink.astro';
import Head2 from './../../components/astro/modules/posts/html/Head2.astro';
import Head3 from './../../components/astro/modules/posts/html/Head3.astro';
import Strong from './../../components/astro/modules/posts/html/Strong.astro';
import Quote from './../../components/astro/modules/posts/html/Quote.astro';

import ListTitle from './../../components/astro/modules/posts/html/ListTitle.astro';
import ListItem from './../../components/astro/modules/posts/html/ListItem.astro';

import Image from './../../components/astro/modules/posts/html/Image.astro';

import CodeSnippet from './../../components/astro/modules/posts/html/CodeSnippet.astro';


export const components = {
  a: TextLink,
  h2: Head2,
  h3: Head3,
  strong: Strong,
  img: Image,
  pre: CodeSnippet,
}

Code coverage has been a engineering metric that is parroted in every single sync up by managers. In the eyes of some managers, code coverage
is the holy grail of metrics for measuring the quality of code that engineers write through rigorous testing.

Unfortunately, this creates a misconception of *higher coverage = better tests* that leads to counter intuitive hacks such as
[assertion-free testing](https://martinfowler.com/bliki/AssertionFreeTesting.html). To resolve this misconception, let's take a look on how
code coverage is calculated.

## Basics of Code Coverage

In modern days, it's really easy to test our code by simply writing test code that will be executed by automated test runners. Test runners
instrument your code and collect various metrics, such as the number of lines, paths, and blocks executed during the test. These metrics collected
during the test will then be compared to the same metrics of the code, resulting in a percentage of code coverage.

To illustrate it better, suppose that we have the following code:

```ts title=math.ts
export function add(a: number, b: number): number {
    return a + b;
}

export function subtract(a: number, b: number): number {
    return a - b;
}

export function divide(a: number, b: number): number {
    return a / b;
}

export function modulo(a: number, b: number): number {
    return a % b;
}
```

which is tested by the following test file:

```ts title=math.spec.ts
import { describe, it, expect } from 'vitest';

import { add, subtract, divide } from './math';

describe('Math Operations', () => {
  it('should add two numbers', () => {
    expect(add(1, 2)).toBe(3);
  });

  it('should subtract two numbers', () => {
    expect(subtract(5, 3)).toBe(2);
  });

  it('should divide two numbers', () => {
    expect(divide(10, 2)).toBe(5);
  });
});
```

After execution, our test runner reports the following code coverage.

```bash no-lang
----------|---------|----------|---------|---------|-------------------
File      | % Stmts | % Branch | % Funcs | % Lines | Uncovered Line #s
----------|---------|----------|---------|---------|-------------------
All files |   86.66 |      100 |      75 |   86.66 |
 math.ts  |   86.66 |      100 |      75 |   86.66 | 14-15
----------|---------|----------|---------|---------|-------------------
```

The code coverage report shows that our test code covers all possible branches but only partially covers
statements, functions, and lines because the modulo function is not executed in any test scenario.

By the example above, code coverage

## What Code Coverage Doesn't Tell You
